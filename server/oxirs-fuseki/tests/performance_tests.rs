//! Performance and stress tests for OxiRS Fuseki enhanced features

use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::Semaphore;
use tokio::time::sleep;

use oxirs_fuseki::handlers::{
    sparql::Sparql12Features,
    websocket::{SubscriptionManager, SubscriptionFilters},
};
use oxirs_fuseki::federation::FederationPlanner;

#[cfg(test)]
mod performance_tests {
    use super::*;

    #[tokio::test]
    async fn test_property_path_optimization_performance() {
        let features = Sparql12Features::new();
        let optimizer = &features.property_path_optimizer;
        
        let test_paths = vec![
            "foaf:knows",
            "foaf:knows/foaf:name",
            "foaf:knows+",
            "foaf:knows*/foaf:name",
            "rdfs:subClassOf*",
            "^foaf:knows/foaf:name",
            "(foaf:knows|rdfs:seeAlso)+",
            "foaf:knows/^foaf:knows/foaf:name",
        ];
        
        let start_time = Instant::now();
        
        // Test optimization of multiple paths
        for path in &test_paths {
            let result = optimizer.optimize_path(path).await;
            assert!(result.is_ok());
        }
        
        let optimization_time = start_time.elapsed();
        println!("Property path optimization time: {:?}", optimization_time);
        
        // Optimization should complete reasonably quickly
        assert!(optimization_time < Duration::from_millis(500));
        
        // Test cache performance
        let start_time = Instant::now();
        
        // Second pass should use cache
        for path in &test_paths {
            let result = optimizer.optimize_path(path).await;
            assert!(result.is_ok());
        }
        
        let cached_time = start_time.elapsed();
        println!("Cached property path optimization time: {:?}", cached_time);
        
        // Cached access should be faster
        assert!(cached_time <= optimization_time);
    }

    #[tokio::test]
    async fn test_concurrent_subscription_management() {
        let manager = SubscriptionManager::new();
        let concurrent_subscriptions = 100;
        let semaphore = Arc::new(Semaphore::new(20)); // Limit concurrency
        
        let start_time = Instant::now();
        
        // Create subscriptions concurrently
        let mut handles = vec![];
        
        for i in 0..concurrent_subscriptions {
            let manager_clone = manager.clone();
            let semaphore_clone = semaphore.clone();
            
            let handle = tokio::spawn(async move {
                let _permit = semaphore_clone.acquire().await.unwrap();
                
                let filters = SubscriptionFilters {
                    min_results: None,
                    max_results: Some(100),
                    graph_filter: None,
                    update_threshold_ms: Some(1000),
                };
                
                manager_clone.add_subscription(
                    format!("SELECT ?s ?p ?o WHERE {{ ?s ?p ?o . FILTER(?s = <http://test.org/entity{}>) }}", i),
                    Some(format!("user_{}", i)),
                    filters,
                ).await
            });
            
            handles.push(handle);
        }
        
        // Wait for all subscriptions to be created
        let mut subscription_ids = vec![];
        for handle in handles {
            let sub_id = handle.await.unwrap();
            subscription_ids.push(sub_id);
        }
        
        let creation_time = start_time.elapsed();
        println!("Created {} subscriptions in {:?}", concurrent_subscriptions, creation_time);
        
        assert_eq!(subscription_ids.len(), concurrent_subscriptions);
        
        // Verify all subscriptions exist
        let active_subs = manager.get_active_subscriptions().await;
        assert_eq!(active_subs.len(), concurrent_subscriptions);
        
        // Test concurrent access performance
        let start_time = Instant::now();
        
        let mut access_handles = vec![];
        for sub_id in &subscription_ids[0..20] { // Test first 20
            let manager_clone = manager.clone();
            let sub_id_clone = sub_id.clone();
            
            let handle = tokio::spawn(async move {
                manager_clone.get_subscription(&sub_id_clone).await
            });
            
            access_handles.push(handle);
        }
        
        for handle in access_handles {
            let result = handle.await.unwrap();
            assert!(result.is_some());
        }
        
        let access_time = start_time.elapsed();
        println!("Concurrent subscription access time: {:?}", access_time);
        
        // Cleanup
        let start_time = Instant::now();
        
        let mut cleanup_handles = vec![];
        for sub_id in subscription_ids {
            let manager_clone = manager.clone();
            
            let handle = tokio::spawn(async move {
                manager_clone.remove_subscription(&sub_id).await
            });
            
            cleanup_handles.push(handle);
        }
        
        for handle in cleanup_handles {
            let removed = handle.await.unwrap();
            assert!(removed);
        }
        
        let cleanup_time = start_time.elapsed();
        println!("Subscription cleanup time: {:?}", cleanup_time);
        
        // Verify all subscriptions are removed
        let final_subs = manager.get_active_subscriptions().await;
        assert_eq!(final_subs.len(), 0);
    }

    #[tokio::test]
    async fn test_federation_planning_performance() {
        let planner = FederationPlanner::new();
        
        // Add multiple test endpoints
        for i in 0..10 {
            let endpoint = create_test_endpoint(&format!("https://endpoint{}.org/sparql", i));
            planner.add_endpoint(endpoint).await.unwrap();
        }
        
        let complex_federated_query = r#"
            SELECT ?person ?name ?age ?interests WHERE {
                ?person foaf:name ?name .
                
                SERVICE <https://endpoint1.org/sparql> {
                    ?person foaf:age ?age .
                    FILTER(?age > 18)
                }
                
                SERVICE <https://endpoint2.org/sparql> {
                    ?person foaf:interest ?interests .
                }
                
                OPTIONAL {
                    SERVICE <https://endpoint3.org/sparql> {
                        ?person foaf:workplaceHomepage ?workplace .
                    }
                }
                
                UNION {
                    SERVICE <https://endpoint4.org/sparql> {
                        ?person foaf:schoolHomepage ?school .
                    }
                }
            }
        "#;
        
        let start_time = Instant::now();
        
        // Test query planning performance
        let plan = planner.create_execution_plan(complex_federated_query).await;
        
        let planning_time = start_time.elapsed();
        println!("Federation planning time: {:?}", planning_time);
        
        assert!(plan.is_ok());
        let exec_plan = plan.unwrap();
        
        // Planning should complete quickly
        assert!(planning_time < Duration::from_millis(200));
        
        // Verify plan structure
        assert!(!exec_plan.execution_steps.is_empty());
        assert!(exec_plan.estimated_cost > 0.0);
        assert!(!exec_plan.resource_requirements.required_endpoints.is_empty());
        
        // Test plan caching
        let start_time = Instant::now();
        
        // Second planning should use cache
        let cached_plan = planner.create_execution_plan(complex_federated_query).await;
        
        let cached_planning_time = start_time.elapsed();
        println!("Cached federation planning time: {:?}", cached_planning_time);
        
        assert!(cached_plan.is_ok());
        // Cached planning should be faster
        assert!(cached_planning_time <= planning_time);
    }

    #[tokio::test]
    async fn test_aggregation_engine_performance() {
        let features = Sparql12Features::new();
        let engine = &features.aggregation_engine;
        
        let complex_query = r#"
            SELECT ?category 
                   (COUNT(*) as ?count)
                   (AVG(?price) as ?avgPrice)
                   (MIN(?price) as ?minPrice)
                   (MAX(?price) as ?maxPrice)
                   (SUM(?price) as ?totalPrice)
                   (GROUP_CONCAT(?name; separator=", ") as ?names)
                   (SAMPLE(?description) as ?sampleDesc)
            WHERE {
                ?item a ?category .
                ?item schema:price ?price .
                ?item schema:name ?name .
                ?item schema:description ?description .
                FILTER(?price > 0)
            }
            GROUP BY ?category
            HAVING (COUNT(*) > 5)
            ORDER BY DESC(?count)
            LIMIT 100
        "#;
        
        let start_time = Instant::now();
        
        // Test aggregation optimization
        let optimized = engine.optimize_aggregation(complex_query).await;
        
        let optimization_time = start_time.elapsed();
        println!("Aggregation optimization time: {:?}", optimization_time);
        
        assert!(optimized.is_ok());
        assert!(optimization_time < Duration::from_millis(50));
    }

    #[tokio::test]
    async fn test_bind_values_processing_performance() {
        let features = Sparql12Features::new();
        let processor = &features.bind_values_processor;
        
        // Create a query with many BIND and VALUES clauses
        let complex_bind_values_query = format!(
            r#"
            SELECT ?s ?computed1 ?computed2 ?computed3 WHERE {{
                VALUES ?type {{ foaf:Person schema:Person }}
                ?s a ?type .
                
                {}
                
                BIND(CONCAT(?s, "_suffix") as ?computed1)
                BIND(STRLEN(?computed1) as ?computed2)
                BIND(?computed2 * 2 as ?computed3)
                
                FILTER(?computed3 > 10)
            }}
            "#,
            (0..20).map(|i| format!("BIND(<http://example.org/entity{}> as ?entity{})", i, i))
                   .collect::<Vec<_>>()
                   .join("\n                ")
        );
        
        let start_time = Instant::now();
        
        // Test BIND/VALUES processing performance
        let processed = processor.process_bind_values(&complex_bind_values_query).await;
        
        let processing_time = start_time.elapsed();
        println!("BIND/VALUES processing time: {:?}", processing_time);
        
        assert!(processed.is_ok());
        assert!(processing_time < Duration::from_millis(100));
    }

    #[tokio::test]
    async fn test_memory_usage_under_load() {
        let manager = SubscriptionManager::new();
        let features = Sparql12Features::new();
        
        // Create many subscriptions to test memory usage
        let subscription_count = 1000;
        let mut subscription_ids = vec![];
        
        for i in 0..subscription_count {
            let filters = SubscriptionFilters {
                min_results: None,
                max_results: Some(100),
                graph_filter: Some(vec![format!("http://test.org/graph{}", i % 10)]),
                update_threshold_ms: Some(1000),
            };
            
            let sub_id = manager.add_subscription(
                format!("SELECT ?s ?p ?o WHERE {{ GRAPH <http://test.org/graph{}> {{ ?s ?p ?o }} }}", i % 10),
                Some(format!("user_{}", i)),
                filters,
            ).await;
            
            subscription_ids.push(sub_id);
            
            // Small delay to prevent overwhelming the system
            if i % 100 == 0 {
                sleep(Duration::from_millis(1)).await;
            }
        }
        
        println!("Created {} subscriptions", subscription_count);
        
        // Verify all subscriptions exist
        let active_subs = manager.get_active_subscriptions().await;
        assert_eq!(active_subs.len(), subscription_count);
        
        // Test property path optimization under load
        let test_paths = vec![
            "foaf:knows+",
            "rdfs:subClassOf*",
            "^foaf:knows/foaf:name",
            "(foaf:knows|rdfs:seeAlso)+",
        ];
        
        let start_time = Instant::now();
        
        for _ in 0..100 {
            for path in &test_paths {
                let result = features.property_path_optimizer.optimize_path(path).await;
                assert!(result.is_ok());
            }
        }
        
        let path_optimization_time = start_time.elapsed();
        println!("Property path optimization under load: {:?}", path_optimization_time);
        
        // Cleanup all subscriptions
        let start_time = Instant::now();
        
        for sub_id in subscription_ids {
            manager.remove_subscription(&sub_id).await;
        }
        
        let cleanup_time = start_time.elapsed();
        println!("Cleanup time for {} subscriptions: {:?}", subscription_count, cleanup_time);
        
        // Verify cleanup
        let final_subs = manager.get_active_subscriptions().await;
        assert_eq!(final_subs.len(), 0);
    }

    #[tokio::test]
    async fn test_stress_change_notifications() {
        let manager = SubscriptionManager::new();
        
        // Create subscriptions with different filter criteria
        let mut subscription_ids = vec![];
        
        for i in 0..50 {
            let filters = SubscriptionFilters {
                min_results: None,
                max_results: Some(1000),
                graph_filter: Some(vec![format!("http://test.org/graph{}", i % 5)]),
                update_threshold_ms: Some(100), // Frequent updates
            };
            
            let sub_id = manager.add_subscription(
                "SELECT ?s ?p ?o WHERE { ?s ?p ?o }".to_string(),
                Some(format!("stress_user_{}", i)),
                filters,
            ).await;
            
            subscription_ids.push(sub_id);
        }
        
        // Generate many change notifications
        let start_time = Instant::now();
        
        for i in 0..200 {
            let notification = oxirs_fuseki::handlers::websocket::ChangeNotification {
                change_type: if i % 2 == 0 { "INSERT" } else { "DELETE" }.to_string(),
                affected_graphs: vec![format!("http://test.org/graph{}", i % 5)],
                timestamp: chrono::Utc::now(),
                change_count: i % 10 + 1,
            };
            
            manager.notify_change(notification).await;
            
            // Small delay to allow processing
            if i % 50 == 0 {
                sleep(Duration::from_millis(5)).await;
            }
        }
        
        let notification_time = start_time.elapsed();
        println!("Processed 200 change notifications in {:?}", notification_time);
        
        // Cleanup
        for sub_id in subscription_ids {
            manager.remove_subscription(&sub_id).await;
        }
    }

    // Helper function to create test endpoints
    fn create_test_endpoint(url: &str) -> oxirs_fuseki::federation::ServiceEndpoint {
        use oxirs_fuseki::federation::{ServiceEndpoint, EndpointCapabilities, HealthStatus};
        use std::collections::HashSet;
        
        ServiceEndpoint {
            url: url.to_string(),
            name: format!("Test Endpoint {}", url),
            capabilities: EndpointCapabilities {
                sparql_version: "1.1".to_string(),
                supported_features: {
                    let mut features = HashSet::new();
                    features.insert("UNION".to_string());
                    features.insert("OPTIONAL".to_string());
                    features.insert("FILTER".to_string());
                    features
                },
                supported_functions: HashSet::new(),
                max_query_length: Some(10000),
                supports_union: true,
                supports_subqueries: true,
                supports_aggregation: true,
                supports_property_paths: true,
                supports_negation: true,
                result_formats: {
                    let mut formats = HashSet::new();
                    formats.insert("application/sparql-results+json".to_string());
                    formats.insert("application/sparql-results+xml".to_string());
                    formats
                },
            },
            statistics: Default::default(),
            health_status: HealthStatus::Healthy,
            authentication: None,
            timeout_ms: 30000,
            priority: 1,
        }
    }
}

#[cfg(test)]
mod benchmark_tests {
    use super::*;
    use std::sync::atomic::{AtomicUsize, Ordering};

    #[tokio::test]
    async fn benchmark_subscription_throughput() {
        let manager = SubscriptionManager::new();
        let operations_count = Arc::new(AtomicUsize::new(0));
        let test_duration = Duration::from_secs(5);
        
        let start_time = Instant::now();
        let mut handles = vec![];
        
        // Spawn multiple tasks to create/remove subscriptions
        for task_id in 0..10 {
            let manager_clone = manager.clone();
            let ops_counter = operations_count.clone();
            
            let handle = tokio::spawn(async move {
                let mut local_ops = 0;
                
                while start_time.elapsed() < test_duration {
                    // Create subscription
                    let filters = SubscriptionFilters {
                        min_results: None,
                        max_results: Some(100),
                        graph_filter: None,
                        update_threshold_ms: Some(1000),
                    };
                    
                    let sub_id = manager_clone.add_subscription(
                        format!("SELECT ?s ?p ?o WHERE {{ ?s ?p ?o . FILTER(?task = {}) }}", task_id),
                        Some(format!("bench_user_{}_{}", task_id, local_ops)),
                        filters,
                    ).await;
                    
                    local_ops += 1;
                    
                    // Occasionally remove subscription
                    if local_ops % 10 == 0 {
                        manager_clone.remove_subscription(&sub_id).await;
                    }
                    
                    // Small delay to prevent overwhelming
                    sleep(Duration::from_millis(1)).await;
                }
                
                ops_counter.fetch_add(local_ops, Ordering::Relaxed);
                local_ops
            });
            
            handles.push(handle);
        }
        
        // Wait for all tasks to complete
        let mut total_ops = 0;
        for handle in handles {
            total_ops += handle.await.unwrap();
        }
        
        let actual_duration = start_time.elapsed();
        let throughput = total_ops as f64 / actual_duration.as_secs_f64();
        
        println!("Subscription throughput: {:.2} ops/sec over {:?}", throughput, actual_duration);
        println!("Total operations: {}", total_ops);
        
        // Cleanup remaining subscriptions
        let remaining = manager.get_active_subscriptions().await;
        for sub in remaining {
            manager.remove_subscription(&sub.id).await;
        }
    }

    #[tokio::test]
    async fn benchmark_property_path_cache_efficiency() {
        let features = Sparql12Features::new();
        let optimizer = &features.property_path_optimizer;
        
        let test_paths = vec![
            "foaf:knows",
            "foaf:knows+",
            "foaf:knows*",
            "rdfs:subClassOf+",
            "^foaf:knows/foaf:name",
            "(foaf:knows|rdfs:seeAlso)+/foaf:name",
        ];
        
        // First pass - populate cache
        let start_time = Instant::now();
        for path in &test_paths {
            optimizer.optimize_path(path).await.unwrap();
        }
        let initial_time = start_time.elapsed();
        
        // Second pass - should use cache
        let start_time = Instant::now();
        for _ in 0..100 {
            for path in &test_paths {
                optimizer.optimize_path(path).await.unwrap();
            }
        }
        let cached_time = start_time.elapsed();
        
        let cache_efficiency = initial_time.as_nanos() as f64 / (cached_time.as_nanos() as f64 / 100.0);
        
        println!("Initial optimization time: {:?}", initial_time);
        println!("Cached optimization time (100 iterations): {:?}", cached_time);
        println!("Cache efficiency: {:.2}x faster", cache_efficiency);
        
        // Cache should provide significant speedup
        assert!(cache_efficiency > 2.0);
    }
}